import bcrypt from 'bcrypt';
import express from 'express';
import { Router } from 'express';
import User from '../models/User.js';
import isAuthenticated from '../middlewares/isAuthenticated.js';

const app = express();
app.use(express.json());
const userRouter = Router();

//USER ROUTES
//allows users to see their own profile


//allows users to update their own profile except role, status, password, and autogenerated db items
userRouter.put("/updateProfile/:user_ID", isAuthenticated, async (req, res) => {
    try {
        const user_id = req.params.user_ID;
        const authenticatedUserId = req.user._id.toString(); // Get the authenticated user's ID
        
        // Check if user is trying to update their own profile
        if (user_id !== authenticatedUserId) {
            return res.status(403).json({ 
                error: 'Access denied. You can only update your own profile.' 
            });
        }
        // Define which fields users cannot update themselves
        const blockedFields = ['role', 'status', '_id', '__v', 'password'];
        const updates = {};
        //will filter out blocked keys
        Object.keys(req.body).forEach(key => {
            if (!blockedFields.includes(key)) {
                updates[key] = req.body[key];
            }
        });
        // Check if user tried to update blocked fields
        const attemptedBlockedFields = Object.keys(req.body).filter(key => 
            blockedFields.includes(key)
        );
        
        if (attemptedBlockedFields.length > 0) {
            return res.status(403).json({ 
                error: `Cannot update the following fields: ${attemptedBlockedFields.join(', ')}` 
            });
        }
        //Check if user tries to update blocked fields.
        const updatedUser = await User.findByIdAndUpdate(
            user_id,
            updates, // Use filtered updates instead of { ...req.body }
            { new: true }
        );
        
        if (!updatedUser) {
            return res.status(404).json({ error: 'User not found' });
        }
        
        res.status(200).json({ notice: 'Profile updated successfully', message: updatedUser });
    } catch (err) {
        res.status(400).json({ error: err.message });
    }
});

// Dedicated route for users to change their passwords
userRouter.put("/changePassword/:user_ID", isAuthenticated, async (req, res) => {
    try {
        const user_id = req.params.user_ID;
        const authenticatedUserId = req.user._id.toString(); // Get the authenticated user's ID
        const { currentPassword, newPassword } = req.body;

        // Validate that password is provided
        if (!newPassword) {
            return res.status(400).json({ error: 'New password is required' });
        }

        // Check if user is trying to update their own profile
        if (user_id !== authenticatedUserId) {
            return res.status(403).json({ 
                error: 'Access denied. You can only update your own password.' 
            });
        }
        
        // Get the user to verify current password
        const user = await User.findById(user_id);
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }

        // Verify current password
        if (!bcrypt.compareSync(currentPassword, user.password)) {
            return res.status(400).json({ error: 'Current password is incorrect' });
        }

        // Hash the new password
        const passwordHash = bcrypt.hashSync(newPassword, 10);

        // Update only the password field
        const updatedUser = await User.findByIdAndUpdate(
            user_id,
            { password: passwordHash },
            { new: true }
        );

        res.status(200).json({ 
            notice: 'Password reset successfully', 
            message: `Password updated for user: ${updatedUser.email}` 
        });
    } catch (err) {
        res.status(400).json({ error: err.message });
    }
});

export default userRouter